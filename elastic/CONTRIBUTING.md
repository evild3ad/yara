## Contributing to YARA Rules

Our team is currently accepting issues related to rule tuning and requests for coverage that are missing against trending malware families. We are also exploring future opportunities to seek contributions in different ways from the community. 

## Table of Contents

- [Submitting an Issue](#submitting-an-issue)
- [Principles around YARA](#principles-around-yara)
- [Quality Testing](#quality-testing)
- [Metadata Schema](#metadata-schema)
- [Recommended Reading](#recommended-reading)

## Submitting an Issue

There are currently two different issue types that can be [chosen from](https://github.com/elastic/protections-artifacts-staging/issues/new/choose) our issue templates. Please leverage the guided instructions within these templates to fill out the issue.
Requests for coverage: Create a suggestion for coverage on malware family that doesn’t currently exist in our repository
Rule tuning: Suggest changes to an existing rule to fix false positives

## Principles around YARA

[YARA](https://virustotal.github.io/yara/) rules provide flexible pattern matching capabilities against data that can be used to identify and group malware families. YARA goes above and beyond standard indicator of compromise (IOC) matching which can be very static in nature, adversaries can make trivial adjustments by modifying a domain/IP/hash effectively bypassing the IOC.

There are many different strategies when leveraging YARA for signatures such as using strings that are observed inside a program. This can be an effective way to identify malware and build detections with YARA, as it's something that can be automated and quickly generated without too much cost (time/resources). With that said, it is very similar to an IOC approach as it's very trivial for adversaries to obfuscate or change out strings so often times there is a need to create stronger anchors for detection such as detecting on the byte sequence for a unique implementation of a cryptographic function which will end up being harder for the adversary to change and possibly require them to re-tool. The downside of using these kinds of methodologies is that it takes time and can require strong expertise with malware analysis and reverse engineering skills.
Our goal with these YARA signatures is to find the balance between these different approaches with the understanding that a signature represents a detection at a point in time. Another key principle that we believe in is leveraging the metadata section of our rules as much as possible to provide more context. This information is vital for bookkeeping purposes and makes it easier for other analysts to follow-up with the rule.

## Quality Testing

In order to ensure quality, our rules go through several internal stages of testing and validation before making it into this repository. These rules are tested against internal and external benign file sources as well as they go through a workflow involving our customer telemetry. 

## Metadata Schema

The metadata within YARA rules is really important since it is the only data available to provide context around the detection logic. When designing this artifact, we picked the following fields below. Some fields are required and some are optional. One of the major components of our testing is based on a tool ([CCCS-Yara](https://github.com/CybercentreCanada/CCCS-Yara)) released by the Canadian Centre for Cyber Security. This tool allows us to validate each rule to our own schema and helps standardize our rules.

| Field | Requirement | Description |
|------------------|---|---------------------------------------------------------------|
| id               | ✓ | Unique UUID that follows the rule throughout entire lifecycle |
| fingerprint      | ✓ | Autogenerated based on SHA256 hash of string values and condition statement of YARA rule |
| creation_date    | ✓ | Creation date of the rule |
| last_modified    | ✓ | Last modified date of the rule |
| os               | ✓ | Describes the OS/platform for rule (Windows, Linux, MacOS) |
| arch_context     | ✓ | Details the architecture (x86, ARM, Sparc) |
| threat_name      | ✓ | Human-friendly name that combines the OS, category type and family name |
| reference_sample | ✓ |  Malware sample related to YARA rule, helpful for testing/reference |
| scan_context     | ✓ | YARA endpoint capability for scanning (File or Memory, if both use "File, Memory") |
| severity         | ✓ | Leveraged for prioritizing the threat name in an alert |
| description      |   | Provides detailed notes and context with rule, mostly found on manual generated rules |
| reference        |   |  Display any kind of reference for the rule (Blog reference, URL, report, etc) |

## Recommended Reading

If you are interested in learning more about YARA, there are tons of great resources out there for learning. Below are some good references and handpicked material involving YARA and different malware topics.

- [YARA Documentation](https://yara.readthedocs.io/en/stable/)
- [Exposing Ryuk Variants Using YARA](https://blog.reversinglabs.com/blog/exposing-ryuk-variants-using-yara)
- [Tracking Threat Actors through YARA Rules and Virus Total](https://www.youtube.com/watch?v=DdkLY99HgAA)
- [To Catch an APT: YARA](https://www.youtube.com/watch?v=YFVZ-tjjWos)
- [Detecting Cobalt Strike with memory signatures](https://www.elastic.co/blog/detecting-cobalt-strike-with-memory-signatures)
